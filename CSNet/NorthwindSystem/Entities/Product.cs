using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

#region Additional Namespaces
using System.ComponentModel.DataAnnotations.Schema;
using System.ComponentModel.DataAnnotations;
#endregion

namespace NorthwindSystem.Entities
{
    //Annotations are used to assist EntityFramework in the mapping of your class to the SQL Table.
    [Table("Products")]

    public class Product
    {
        private string _QuantityPerUnit;
        //If you use the same name as the SQL attribute for your Property name, order of properties does not matter
        //If your names are different then order is required


        //[Key] single attribute PK, identity PK
        //[Key, Column(Order = n)] compound PKs required in fron of each propery, n represents the physical order as found on SQL table
        //          .xxxx --> Identity: PK on SQL is an Identity PK
        //          default
        //          --> None: PK is NOT Idenity, user entered
        //          Computed attribute is a sql computed attribute which means that NO actual data is stored in the SQL table, it is generated by the expression in the SQL Table
        [Key]  //Identifies Attribute as PK
        public int ProductID { get; set; }



        //validation annotation
        //Place the annotation validation in FRONT of the property associated with 
        [Required(ErrorMessage = "Product Name is required.")]
        [StringLength(40, ErrorMessage = "ProductName is limited to 40 characters.")]
        public int? CategoryID { get; set; } //? == nullable
        public string ProductName { get; set; }


        //This foreign Key is nullable on the SQL Table
        //You may be tempted to use the [ForeignKey] annotation
        // BUT DON'T
        //The [ForeignKey] annotation is ONLY required if the SQL table does not use the same name for it's ForeignKey as it's parent Primary Key 
        //  OR
        //If your property name does not match the SQL attribute name
        public int? SupplierID { get; set; }


        //Nullable strings can still be fully implemented
        [StringLength(20, ErrorMessage = "Quantity per Unit is limited to 20 characters.")]
        public string QuantityPerUnit
        {
            get { return _QuantityPerUnit;  }
            set { _QuantityPerUnit = string.IsNullOrEmpty(value) ? null : value; }
        }

        //Money requires the use of decimal; if it complains use double
        [Range(0, int.MaxValue, ErrorMessage = "Unit Price is 0.00 or greater dollars. ")]
        public Decimal UnitPrice { get; set; } //Decimal for money


        [Range(0, 32767, ErrorMessage = "Unit in Stock is must be greater than 0. ")]
        public Int16 UnitsInStock { get; set; } //iny16 is for an small int



        [Range(0, 32767, ErrorMessage = "Units on Order is must be greater than 0. ")]
        public Int16 UnitsOnOrder { get; set; }



        [Range(0.00, 32767, ErrorMessage = "Reorder Level is must be greater than 0. ")]
        public Int16 ReorderLevel { get; set; }

        public bool Discontinued { get; set; }


        // Re-Only properties that are setup in your class to make programming easier
        //NEVER try to load this property with data. THERE IS NO set !!!! (we just read it)
        [NotMapped]
        public string NameAndID
        {
            get { return ProductName + "(" + ProductID + ")"; }
        }
    }
}
